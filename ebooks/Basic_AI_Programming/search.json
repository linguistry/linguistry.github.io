[
  {
    "objectID": "06.arithmetic.html",
    "href": "06.arithmetic.html",
    "title": "6  Basic Arithmetic Operations in Python",
    "section": "",
    "text": "6.1 Simple Examples with Numbers",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Arithmetic Operations in Python</span>"
    ]
  },
  {
    "objectID": "06.arithmetic.html#simple-examples-with-numbers",
    "href": "06.arithmetic.html#simple-examples-with-numbers",
    "title": "6  Basic Arithmetic Operations in Python",
    "section": "",
    "text": "6.1.1 Addition (+)\nThe addition operator adds two numbers together.\na = 10\nb = 5\nresult = a + b\nprint(result)  # Output: 15\n\n\n6.1.2 Subtraction (-)\nThe subtraction operator subtracts the second number from the first.\na = 10\nb = 5\nresult = a - b\nprint(result)  # Output: 5\n\n\n6.1.3 Multiplication (*)\nThe multiplication operator multiplies two numbers.\na = 10\nb = 5\nresult = a * b\nprint(result)  # Output: 50\n\n\n6.1.4 Division (/)\nThe division operator divides the first number by the second.\na = 10\nb = 5\nresult = a / b\nprint(result)  # Output: 2.0\n\n\n6.1.5 Modulus (%)\nThe modulus operator returns the remainder of the division of the first number by the second.\na = 10\nb = 3\nresult = a % b\nprint(result)  # Output: 1\n\n6.1.5.1 Example Explanation\nIn this example, 10 % 3 computes the remainder when 10 is divided by 3, which is 1.\n\n\n\n6.1.6 Exponentiation (**)\nThe exponentiation operator raises the first number to the power of the second.\na = 2\nb = 3\nresult = a ** b\nprint(result)  # Output: 8\n\n\n6.1.7 Floor Division (//)\nThe floor division operator divides and returns the largest integer less than or equal to the result.\na = 10\nb = 3\nresult = a // b\nprint(result)  # Output: 3\n\n\n6.1.8 divmod() Function\nThe divmod() function returns a tuple containing the quotient and the remainder when dividing two numbers.\na = 10\nb = 3\nquotient, remainder = divmod(a, b)\nprint(f\"Quotient: {quotient}, Remainder: {remainder}\")\n# Output: Quotient: 3, Remainder: 1\n\n6.1.8.1 Example Explanation\nHere, divmod(10, 3) returns (3, 1), where 3 is the quotient and 1 is the remainder when 10 is divided by 3.\n\n\n\n6.1.9 Summary Table\n\n\n\n\n\n\n\n\n\nOperator/Function\nDescription\nExample\nOutput\n\n\n\n\n+\nAddition\n10 + 5\n15\n\n\n-\nSubtraction\n10 - 5\n5\n\n\n*\nMultiplication\n10 * 5\n50\n\n\n/\nDivision\n10 / 5\n2.0\n\n\n%\nModulus (Remainder)\n10 % 3\n1\n\n\n**\nExponentiation\n2 ** 3\n8\n\n\n//\nFloor Division\n10 // 3\n3\n\n\ndivmod()\nQuotient and Remainder as a Tuple\ndivmod(10, 3)\n(3, 1)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Arithmetic Operations in Python</span>"
    ]
  },
  {
    "objectID": "06.arithmetic.html#advanced-examples-with-dataframes",
    "href": "06.arithmetic.html#advanced-examples-with-dataframes",
    "title": "6  Basic Arithmetic Operations in Python",
    "section": "6.2 Advanced Examples with DataFrames",
    "text": "6.2 Advanced Examples with DataFrames\nIn data analysis, we often work with tabular data. The pandas library provides a powerful DataFrame object to handle such data. Arithmetic operations can be applied to DataFrame objects directly, enabling efficient data manipulation.\n\n6.2.1 Setting Up the Environment\nFirst, install and import the necessary library:\n# Install pandas if not already installed\n# !pip install pandas\n\nimport pandas as pd\n\n\n6.2.2 Creating a DataFrame\nLet’s create a simple DataFrame for demonstration:\ndata = {\n    'A': [10, 20, 30],\n    'B': [1, 2, 3],\n    'C': [5, 4, 3]\n}\ndf = pd.DataFrame(data)\nprint(df)\nOutput:\n    A  B  C\n0  10  1  5\n1  20  2  4\n2  30  3  3\n\n\n6.2.3 Adding a Constant to a Column\nYou can add a constant value to an entire column:\ndf['A_plus_10'] = df['A'] + 10\nprint(df)\nOutput:\n    A  B  C  A_plus_10\n0  10  1  5         20\n1  20  2  4         30\n2  30  3  3         40\n\n\n6.2.4 Column-Wise Operations\nPerform arithmetic operations between columns:\ndf['A_minus_C'] = df['A'] - df['C']\nprint(df)\nOutput:\n    A  B  C  A_plus_10  A_minus_C\n0  10  1  5         20          5\n1  20  2  4         30         16\n2  30  3  3         40         27\n\n\n6.2.5 Using Modulus Operator with DataFrames\nApply the modulus operator to a DataFrame column to get the remainder of division element-wise:\ndf['A_mod_3'] = df['A'] % 3\nprint(df)\nOutput:\n    A  B  C  A_plus_10  A_minus_C  A_mod_3\n0  10  1  5         20          5        1\n1  20  2  4         30         16        2\n2  30  3  3         40         27        0\n\n6.2.5.1 Example Explanation\n\nFor row 0: 10 % 3 equals 1.\nFor row 1: 20 % 3 equals 2.\nFor row 2: 30 % 3 equals 0.\n\n\n\n\n6.2.6 Using divmod() with DataFrames\nWhile divmod() isn’t directly applicable to DataFrame columns, you can achieve similar results using apply along with a lambda function:\ndf[['Quotient', 'Remainder']] = df['A'].apply(lambda x: pd.Series(divmod(x, 3)))\nprint(df)\nOutput:\n    A  B  C  A_plus_10  A_minus_C  A_mod_3  Quotient  Remainder\n0  10  1  5         20          5        1         3          1\n1  20  2  4         30         16        2         6          2\n2  30  3  3         40         27        0        10          0\n\n6.2.6.1 Example Explanation\n\nFor row 0: divmod(10, 3) returns (3, 1).\nFor row 1: divmod(20, 3) returns (6, 2).\nFor row 2: divmod(30, 3) returns (10, 0).\n\n\n\n\n6.2.7 Row-Wise Operations\nUse the sum function to perform operations across rows:\ndf['Sum_A_B_C'] = df[['A', 'B', 'C']].sum(axis=1)\nprint(df)\nOutput:\n    A  B  C  A_plus_10  A_minus_C  A_mod_3  Quotient  Remainder  Sum_A_B_C\n0  10  1  5         20          5        1         3          1         16\n1  20  2  4         30         16        2         6          2         26\n2  30  3  3         40         27        0        10          0         36\n\n\n6.2.8 Applying Functions\nApply a function to a column:\ndf['A_squared'] = df['A'].apply(lambda x: x ** 2)\nprint(df)\nOutput:\n    A  B  C  A_plus_10  A_minus_C  A_mod_3  Quotient  Remainder  Sum_A_B_C  A_squared\n0  10  1  5         20          5        1         3          1         16        100\n1  20  2  4         30         16        2         6          2         26        400\n2  30  3  3         40         27        0        10          0         36        900\n\n\n6.2.9 Conditional Operations\nUse conditions to modify data:\ndf['A_gt_15'] = df['A'] &gt; 15\nprint(df)\nOutput:\n    A  B  C  A_plus_10  A_minus_C  A_mod_3  Quotient  Remainder  Sum_A_B_C  A_squared  A_gt_15\n0  10  1  5         20          5        1         3          1         16        100    False\n1  20  2  4         30         16        2         6          2         26        400     True\n2  30  3  3         40         27        0        10          0         36        900     True\n\n\n6.2.10 Handling Missing Data\nArithmetic operations handle missing data (NaN) gracefully:\ndf.loc[1, 'B'] = None  # Introduce a NaN value\ndf['B_plus_2'] = df['B'] + 2\nprint(df)\nOutput:\n    A    B  C  A_plus_10  A_minus_C  A_mod_3  Quotient  Remainder  Sum_A_B_C  A_squared  A_gt_15  B_plus_2\n0  10  1.0  5         20          5        1         3          1       16.0        100    False       3.0\n1  20  NaN  4         30         16        2         6          2        NaN        400     True       NaN\n2  30  3.0  3         40         27        0        10          0       36.0        900     True       5.0\nThis code snippet demonstrates how to introduce a missing value (NaN) into a DataFrame and perform an arithmetic operation on a column that contains NaN values. Let me break down the key points:\n\n\n6.2.11 Explanation of Code:\n\nIntroducing a Missing Value:\ndf.loc[1, 'B'] = None  # Introduce a NaN value\nThis line sets the value at row index 1 in column 'B' to None, which pandas treats as NaN (Not a Number). This introduces a missing value in the DataFrame.\nPerforming Arithmetic with NaN:\ndf['B_plus_2'] = df['B'] + 2\nThis line creates a new column, 'B_plus_2', by adding 2 to the values in column 'B'. When you perform arithmetic with NaN in pandas, the result for that specific operation is also NaN. This is why in the resulting DataFrame, the row with NaN in column 'B' also has NaN in the new column 'B_plus_2'.\n\n\n\n6.2.12 Grouped Operations\nPerform operations on grouped data:\ndf['Group'] = ['X', 'Y', 'X']\n\nprint(df)\nprint('---')\n\ngrouped = df.groupby('Group')\nsum_per_group = grouped['A'].sum()\nprint(sum_per_group)\nOutput:\nGroup\nX    40\nY    20\nName: A, dtype: int64",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Arithmetic Operations in Python</span>"
    ]
  },
  {
    "objectID": "06.arithmetic.html#summary",
    "href": "06.arithmetic.html#summary",
    "title": "6  Basic Arithmetic Operations in Python",
    "section": "6.3 Summary",
    "text": "6.3 Summary\nUnderstanding basic arithmetic operations in Python is essential for both simple calculations and complex data manipulations. With numbers, these operations are straightforward. When working with DataFrame objects in pandas, the same arithmetic operators can be applied to perform element-wise operations, making data analysis tasks more efficient.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Arithmetic Operations in Python</span>"
    ]
  },
  {
    "objectID": "01.setup.html",
    "href": "01.setup.html",
    "title": "1  Setting Up Environment",
    "section": "",
    "text": "1.1 Setting Up VSCode for Data Analysis\nVisual Studio Code (VSCode) is a free, open-source code editor developed by Microsoft. It supports multiple programming languages, extensions, and integrations, making it an excellent choice for data analysis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting Up Environment</span>"
    ]
  },
  {
    "objectID": "01.setup.html#setting-up-vscode-for-data-analysis",
    "href": "01.setup.html#setting-up-vscode-for-data-analysis",
    "title": "1  Setting Up Environment",
    "section": "",
    "text": "1.1.1 Installing VSCode\n\nDownload VSCode: Visit the VSCode official website and download the installer for your operating system (Windows, macOS, or Linux).\nInstall VSCode: Run the installer and follow the installation instructions.\n\n\n\n1.1.2 Setting Up Python in VSCode\n\nInstall Python: Ensure Python is installed on your system. You can download it from the official Python website.\nInstall Python Extension for VSCode:\n\nOpen VSCode and go to the Extensions view by clicking on the Extensions icon in the sidebar or pressing Ctrl+Shift+X.\nSearch for “Python” and install the extension provided by Microsoft.\n\nVerify Python Installation:\n\nOpen a terminal in VSCode (`Ctrl+``) and type:\npython --version\nYou should see the installed Python version. If not, check your installation path.\n\nSet Up a Virtual Environment (Optional but recommended):\n\nCreate a virtual environment to manage dependencies for your project:\npython -m venv myenv\nActivate the virtual environment:\n\nWindows: myenv\\Scripts\\activate\nmacOS/Linux: source myenv/bin/activate\n\n\nInstall Essential Libraries:\n\nUse pip to install essential libraries like pandas, NumPy, and matplotlib:\npip install pandas numpy matplotlib seaborn\n\nCreate a Python File:\n\nOpen a new file, save it with a .py extension, and write your first Python code. For example:\nimport pandas as pd\nimport numpy as np\n\n# Create a simple DataFrame\ndata = {'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [25, 30, 35]}\ndf = pd.DataFrame(data)\n\nprint(df)\n\nRunning Python Code:\n\nRun the code by clicking the “Run” button at the top right or by pressing F5.\n\n\n\n\n1.1.3 Additional Tips\n\nJupyter Notebook in VSCode: You can also use Jupyter notebooks within VSCode by installing the Jupyter extension.\nLinting and Formatting: Use extensions like Pylint or Black to maintain code quality.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting Up Environment</span>"
    ]
  },
  {
    "objectID": "01.setup.html#setting-up-google-colab-for-data-analysis",
    "href": "01.setup.html#setting-up-google-colab-for-data-analysis",
    "title": "1  Setting Up Environment",
    "section": "1.2 Setting Up Google Colab for Data Analysis",
    "text": "1.2 Setting Up Google Colab for Data Analysis\nGoogle Colab is a free, cloud-based platform that provides Jupyter Notebook environments. It allows you to write and execute Python code in your browser, making it a great tool for data analysis, especially when dealing with large datasets and GPU-based computations.\n\n1.2.1 Getting Started with Google Colab\n\nAccess Google Colab:\n\nGo to Google Colab using your Google account.\n\nCreating a New Notebook:\n\nClick on “New Notebook” to create a new notebook. This will open a new page with a code cell ready to run.\n\nInstalling and Importing Libraries:\n\nUse pip to install any additional libraries you need directly within a cell:\n# Install pandas and numpy\n!pip install pandas numpy\n\nWriting and Running Code:\n\nWrite your code in the code cells and run it by clicking the play button on the left side of the cell or pressing Shift+Enter.\nimport pandas as pd\nimport numpy as np\n\n# Creating a DataFrame\ndata = {'Product': ['Apples', 'Bananas', 'Cherries'], 'Price': [1.2, 0.8, 2.5]}\ndf = pd.DataFrame(data)\n\n# Displaying the DataFrame\nprint(df)\n\n\n\n\n1.2.2 Uploading Files and Connecting to Google Drive\n\nUploading Files: You can upload files directly to the Colab environment by using the file upload button on the left sidebar.\nConnecting to Google Drive: If you have data stored on Google Drive, you can easily access it by mounting your drive.\nfrom google.colab import drive\ndrive.mount('/content/drive')\nThis code will prompt you to authorize access to your Google Drive.\n\n\n\n1.2.3 Using GPU or TPU for Accelerated Computing\nGoogle Colab allows you to use GPUs or TPUs to speed up your computations, especially useful for machine learning tasks.\n\nChanging Runtime Type:\n\nGo to Runtime &gt; Change runtime type.\nSelect “GPU” or “TPU” under “Hardware accelerator” and click “Save”.\n\n\n\n\n1.2.4 Saving and Exporting Your Work\n\nSaving Notebooks: Colab automatically saves your work to Google Drive, but you can also save a copy manually by selecting File &gt; Save a copy in Drive.\nExporting Notebooks: You can download your notebook as a .ipynb or .py file by selecting File &gt; Download.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting Up Environment</span>"
    ]
  },
  {
    "objectID": "01.setup.html#summary",
    "href": "01.setup.html#summary",
    "title": "1  Setting Up Environment",
    "section": "1.3 Summary",
    "text": "1.3 Summary\n\nVSCode is great for local development with rich support for extensions, virtual environments, and debugging.\nGoogle Colab is ideal for cloud-based development, especially when you need quick access to computational resources like GPUs and TPUs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting Up Environment</span>"
    ]
  },
  {
    "objectID": "02.intro.html",
    "href": "02.intro.html",
    "title": "2  Constants and Variables in Python",
    "section": "",
    "text": "2.1 Variables in Python\nA variable is a named location in memory used to store data that can change during the execution of a program. Variables can hold different types of data, such as numbers, strings, or more complex data structures.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#variables-in-python",
    "href": "02.intro.html#variables-in-python",
    "title": "2  Constants and Variables in Python",
    "section": "",
    "text": "2.1.1 Declaring Variables\nTo declare a variable in Python, you simply assign a value to a name using the assignment operator =. Python is dynamically typed, meaning you do not need to declare the type of the variable explicitly.\n# Variable declaration\nx = 10           # An integer variable\nname = \"Alice\"   # A string variable\npi = 3.14159     # A float variable\n\nprint(x)         # Output: 10\nprint(name)      # Output: Alice\nprint(pi)        # Output: 3.14159\n# Updating variable values\nx = 20           # Reassigning a new value to x\nname = \"Bob\"     # Changing the value of name\n\nprint(x)         # Output: 20\nprint(name)      # Output: Bob",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#constants-in-python",
    "href": "02.intro.html#constants-in-python",
    "title": "2  Constants and Variables in Python",
    "section": "2.2 Constants in Python",
    "text": "2.2 Constants in Python\nA constant is a value that does not change during the execution of a program. Python does not have a built-in way to define constants explicitly, but naming conventions are used to indicate that a variable should be treated as a constant.\n\n2.2.1 Defining Constants\nPython does not have a specific syntax for defining constants. However, by convention, constants are written in all uppercase letters, and these variables are not supposed to be modified.\n# Defining constants (by convention)\nMAX_SPEED = 120          # A constant integer\nGRAVITY = 9.81           # A constant float\nWELCOME_MESSAGE = \"Hello\" # A constant string\n\nprint(MAX_SPEED)         # Output: 120\nprint(GRAVITY)           # Output: 9.81\nprint(WELCOME_MESSAGE)   # Output: Hello",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#numeric-data-types",
    "href": "02.intro.html#numeric-data-types",
    "title": "2  Constants and Variables in Python",
    "section": "3.1 Numeric Data Types",
    "text": "3.1 Numeric Data Types\n\n3.1.1 Integer (int)\nIntegers are whole numbers, positive or negative, without decimals.\n# Integer example\nage = 25\nprint(age)        # Output: 25\nprint(type(age))  # Output: &lt;class 'int'&gt;\n\n\n3.1.2 Float (float)\nFloats represent numbers with decimal points.\n# Float example\nheight = 5.9\nprint(height)        # Output: 5.9\nprint(type(height))  # Output: &lt;class 'float'&gt;\n\n\n3.1.3 Complex (complex)\nComplex numbers consist of a real and an imaginary part.\n# Complex number example\nz = 3 + 4j\nprint(z)            # Output: (3+4j)\nprint(type(z))      # Output: &lt;class 'complex'&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#sequence-data-types",
    "href": "02.intro.html#sequence-data-types",
    "title": "2  Constants and Variables in Python",
    "section": "3.2 Sequence Data Types",
    "text": "3.2 Sequence Data Types\n\n3.2.1 String (str)\nStrings are sequences of characters enclosed in quotes.\n# String example\nname = \"Python\"\nprint(name)        # Output: Python\nprint(type(name))  # Output: &lt;class 'str'&gt;\n\n\n3.2.2 List (list)\nLists are ordered, mutable collections of items that can hold mixed data types.\n# List example\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(fruits)        # Output: ['apple', 'banana', 'cherry']\nprint(type(fruits))  # Output: &lt;class 'list'&gt;\n\n3.2.2.1 List Indexing and Slicing\nIndexing allows you to access individual elements in a list using their position, while slicing lets you extract a sublist from a list.\n\n3.2.2.1.1 Indexing\nIndexing starts at 0. Negative indices can be used to access elements from the end of the list.\n# List indexing example\nfruits = ['apple', 'banana', 'cherry']\n\n# Accessing elements\nprint(fruits[0])  # Output: apple\nprint(fruits[-1]) # Output: cherry\n\n\n3.2.2.1.2 Slicing\nSlicing allows you to extract a range of elements. The syntax is list[start:end], where start is inclusive and end is exclusive.\n# List slicing example\nnumbers = [0, 1, 2, 3, 4, 5]\n\n# Extracting a sublist\nprint(numbers[1:4])   # Output: [1, 2, 3]\nprint(numbers[:3])    # Output: [0, 1, 2] (from the start to index 2)\nprint(numbers[3:])    # Output: [3, 4, 5] (from index 3 to the end)\nprint(numbers[-3:])   # Output: [3, 4, 5] (last three elements)\n\n\n\n3.2.2.2 Adding Elements to a List\nYou can add elements to a list using methods like append(), insert(), and extend().\n\n3.2.2.2.1 Using append()\nappend() adds an element to the end of the list.\n# Using append() to add an element\nnumbers = [1, 2, 3]\nnumbers.append(4)\nprint(numbers)  # Output: [1, 2, 3, 4]\n\n\n3.2.2.2.2 Using insert()\ninsert() adds an element at a specified position.\n# Using insert() to add an element at a specific position\nnumbers = [1, 3, 4]\nnumbers.insert(1, 2)  # Insert 2 at index 1\nprint(numbers)  # Output: [1, 2, 3, 4]\n\n\n3.2.2.2.3 Using extend()\nextend() adds multiple elements to the end of the list.\n# Using extend() to add multiple elements\nnumbers = [1, 2]\nnumbers.extend([3, 4, 5])\nprint(numbers)  # Output: [1, 2, 3, 4, 5]\n\n\n\n3.2.2.3 Modifying and Deleting List Elements\nYou can modify or remove elements from a list using index assignments, remove(), pop(), or del.\n\n3.2.2.3.1 Modifying Elements\nAssign a new value to an index to modify an element.\n# Modifying an element in the list\nnumbers = [1, 2, 3]\nnumbers[1] = 20\nprint(numbers)  # Output: [1, 20, 3]\n\n\n3.2.2.3.2 Deleting Elements\nUse remove() to delete an element by value, pop() to remove by index, or del to delete a slice.\n# Using remove() to delete by value\nnumbers = [1, 2, 3, 4]\nnumbers.remove(3)\nprint(numbers)  # Output: [1, 2, 4]\n\n# Using pop() to delete by index\nnumbers = [1, 2, 3, 4]\nremoved_element = numbers.pop(1)\nprint(numbers)  # Output: [1, 3, 4]\nprint(removed_element)  # Output: 2\n\n# Using del to delete by index or slice\nnumbers = [1, 2, 3, 4, 5]\ndel numbers[1:3]\nprint(numbers)  # Output: [1, 4, 5]\n\n\n\n3.2.2.4 Sorting Lists\nUse sort() to sort a list in place, or sorted() to return a new sorted list.\n# Sorting a list in ascending order\nnumbers = [3, 1, 4, 1, 5]\nnumbers.sort()\nprint(numbers)  # Output: [1, 1, 3, 4, 5]\n\n# Sorting a list in descending order\nnumbers.sort(reverse=True)\nprint(numbers)  # Output: [5, 4, 3, 1, 1]\n\n# Using sorted() to return a new sorted list\nnew_numbers = sorted(numbers)\nprint(new_numbers)  # Output: [1, 1, 3, 4, 5]\n\n\n\n3.2.3 3. Tuple (tuple)\nA tuple is an ordered, immutable collection of elements. Tuples are similar to lists but cannot be modified after creation.\n# Creating and accessing tuples\ncoordinates = (10, 20)\nprint(coordinates)        # Output: (10, 20)\nprint(coordinates[0])     # Output: 10\n\n# Tuples are immutable; attempting to modify will raise an error\n# coordinates[0] = 30  # This would cause an error",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#mapping-data-type",
    "href": "02.intro.html#mapping-data-type",
    "title": "2  Constants and Variables in Python",
    "section": "3.3 Mapping Data Type",
    "text": "3.3 Mapping Data Type\n\n3.3.1 Dictionary (dict)\nA dictionary is a collection of key-value pairs, where each key is unique. Dictionaries are mutable, allowing for dynamic updates.\n# Dictionary example\nperson = {\"name\": \"Alice\", \"age\": 30}\nprint(person)        # Output: {'name': 'Alice', 'age': 30}\nprint(type(person))  # Output: &lt;class 'dict'&gt;\n\n3.3.1.1 Accessing Values Using Keys\nAccess values in a dictionary using keys.\n# Accessing values using keys\nname = person[\"name\"]\nage = person.get(\"age\")\nprint(name)  # Output: Alice\nprint(age)   # Output: 30\n\n\n3.3.1.2 Adding and Removing Key-Value Pairs\nYou can add new key-value pairs or remove existing ones using methods like update(), del, or pop().\n\n3.3.1.2.1 Adding Key-Value Pairs\n# Adding new key-value pairs\nperson[\"city\"] = \"New York\"\nprint(person)  # Output: {'name': 'Alice', 'age': 30, 'city': 'New York'}\n\n\n3.3.1.2.2 Removing Key-Value Pairs\n# Removing a key-value pair using pop()\nremoved_value = person.pop(\"age\")\nprint(person)        # Output: {'name': 'Alice', 'city': 'New York'}\nprint(removed_value) # Output: 30\n\n# Removing a key-value pair using del\ndel person[\"city\"]\nprint(person)  # Output: {'name': 'Alice'}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#set-data-types",
    "href": "02.intro.html#set-data-types",
    "title": "2  Constants and Variables in Python",
    "section": "3.4 Set Data Types",
    "text": "3.4 Set Data Types\n\n3.4.1 Set (set)\nSets are unordered collections of unique items.\n# Set example\nnumbers = {1, 2, 3, 4}\nprint(numbers)        # Output: {1, 2, 3, 4}\nprint(type(numbers))  # Output: &lt;class 'set'&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#boolean-data-type",
    "href": "02.intro.html#boolean-data-type",
    "title": "2  Constants and Variables in Python",
    "section": "3.5 Boolean Data Type",
    "text": "3.5 Boolean Data Type\n\n3.5.1 Boolean (bool)\nBooleans represent one of two values: True or False.\n# Boolean example\nis_active = True\nprint(is_active)        # Output: True\nprint(type(is_active))  # Output: &lt;class 'bool'&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#f-string-formatting-in-python",
    "href": "02.intro.html#f-string-formatting-in-python",
    "title": "2  Constants and Variables in Python",
    "section": "3.6 f-string Formatting in Python",
    "text": "3.6 f-string Formatting in Python\nf-strings, introduced in Python 3.6, are a modern and powerful way to format strings. They offer a concise and readable syntax, allowing you to embed expressions directly inside string literals by prefixing the string with the letter f or F.\nf-strings make string formatting simpler and more intuitive compared to older methods such as % formatting or the str.format() method. They allow for inline expression evaluation, formatting of numbers, and easy manipulation of string data.\n\n3.6.1 Embedding Variables\nTo use f-strings, simply place an f before the opening quote of the string and include expressions inside curly braces {}.\n# Basic usage of f-string\nname = \"Alice\"\nage = 30\n\n# Embedding variables in a string\ngreeting = f\"Hello, {name}! You are {age} years old.\"\nprint(greeting)  # Output: Hello, Alice! You are 30 years old.\n\n\n3.6.2 Inline Expressions\nf-strings allow you to include any valid Python expression inside the curly braces.\n# Using expressions inside f-strings\nx = 10\ny = 5\n\n# Inline arithmetic expression\nresult = f\"{x} + {y} = {x + y}\"\nprint(result)  # Output: 10 + 5 = 15",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "02.intro.html#advanced-formatting-with-f-strings",
    "href": "02.intro.html#advanced-formatting-with-f-strings",
    "title": "2  Constants and Variables in Python",
    "section": "3.7 Advanced Formatting with f-strings",
    "text": "3.7 Advanced Formatting with f-strings\n\n3.7.1 Number Formatting\nf-strings provide options to format numbers in various ways, such as controlling decimal places, adding commas, or displaying percentages.\n\n3.7.1.1 Formatting Floats\nYou can specify the number of decimal places by using .nf, where n is the number of decimal places.\n# Formatting a float to 2 decimal places\npi = 3.14159265358979\nformatted_pi = f\"Pi rounded to 2 decimal places: {pi:.2f}\"\nprint(formatted_pi)  # Output: Pi rounded to 2 decimal places: 3.14\n\n\n3.7.1.2 Adding Commas to Large Numbers\nUse the :, format specifier to include commas as thousand separators.\n# Adding commas to large numbers\nlarge_number = 1000000\nformatted_number = f\"The number is: {large_number:,}\"\nprint(formatted_number)  # Output: The number is: 1,000,000\n\n\n3.7.1.3 Displaying Percentages\nTo display a number as a percentage, use the % format specifier.\n# Displaying a percentage\nsuccess_rate = 0.85\nformatted_rate = f\"Success rate: {success_rate:.2%}\"\nprint(formatted_rate)  # Output: Success rate: 85.00%\n\n\n\n3.7.2 Embedding Dictionary Values\nf-strings can also be used to format values from dictionaries.\n# Formatting dictionary values\nperson = {\"name\": \"Bob\", \"age\": 40}\nformatted_string = f\"{person['name']} is {person['age']} years old.\"\nprint(formatted_string)  # Output: Bob is 40 years old.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Constants and Variables in Python</span>"
    ]
  },
  {
    "objectID": "03.control.html",
    "href": "03.control.html",
    "title": "3  Control Structures in Python",
    "section": "",
    "text": "3.1 Control Structures",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures in Python</span>"
    ]
  },
  {
    "objectID": "03.control.html#control-structures",
    "href": "03.control.html#control-structures",
    "title": "3  Control Structures in Python",
    "section": "",
    "text": "3.1.1 if Statement\nThe if statement is used to execute a block of code only if a specified condition is true. You can use if, elif (else if), and else to build more complex conditions.\n\n3.1.1.1 Basic if Statement\n# Basic if statement\nage = 18\nif age &gt;= 18:\n    print(\"You are an adult.\")  # Output: You are an adult.\n\n\n3.1.1.2 if-elif-else Structure\nYou can chain multiple conditions using elif and provide a default action using else.\n# if-elif-else example\nscore = 85\nif score &gt;= 90:\n    print(\"Grade: A\")\nelif score &gt;= 80:\n    print(\"Grade: B\")  # Output: Grade: B\nelif score &gt;= 70:\n    print(\"Grade: C\")\nelse:\n    print(\"Grade: F\")\n\n\n3.1.1.3 Nested if Statements\nif statements can be nested within each other to handle complex conditions.\n# Nested if statement\nnumber = 10\nif number &gt; 0:\n    print(\"Positive number\")  # Output: Positive number\n    if number % 2 == 0:\n        print(\"Even number\")  # Output: Even number\n\n\n\n3.1.2 while Loop\nThe while loop repeatedly executes a block of code as long as the specified condition is true. It is used when the number of iterations is not known in advance.\n\n3.1.2.1 Basic while Loop\n# Basic while loop\ncount = 1\nwhile count &lt;= 5:\n    print(count)  # Output: 1 2 3 4 5\n    count += 1\n\n\n3.1.2.2 while Loop with break and continue\n\nbreak: Exits the loop immediately.\ncontinue: Skips the current iteration and moves to the next one.\n\n# Using break and continue in a while loop\nnum = 0\nwhile num &lt; 10:\n    num += 1\n    if num == 5:\n        continue  # Skip the number 5\n    if num == 8:\n        break  # Exit the loop when num is 8\n    print(num)  # Output: 1 2 3 4 6 7\n\n\n\n3.1.3 for Loop\nThe for loop iterates over a sequence (such as a list, tuple, string, or range). It is used when the number of iterations is known.\n\n3.1.3.1 Basic for Loop\n# Basic for loop\nfor i in range(5):\n    print(i)  # Output: 0 1 2 3 4\n\n\n3.1.3.2 Iterating Over a List\n# Iterating over a list\nfruits = ['apple', 'banana', 'cherry']\nfor fruit in fruits:\n    print(fruit)  # Output: apple banana cherry\n\n\n3.1.3.3 for Loop with break and continue\n# Using break and continue in a for loop\nfor num in range(1, 10):\n    if num == 4:\n        continue  # Skip number 4\n    if num == 7:\n        break  # Stop the loop when num is 7\n    print(num)  # Output: 1 2 3 5 6\n\n\n\n3.1.4 Exception Handling\nException handling allows you to manage errors gracefully without crashing your program. Use try, except, else, and finally blocks to handle exceptions.\n\n3.1.4.1 Basic Exception Handling with try and except\n# Basic try-except block\ntry:\n    result = 10 / 0  # This will raise a ZeroDivisionError\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")  # Output: Cannot divide by zero!\n\n\n3.1.4.2 Multiple Exceptions\nYou can handle multiple exceptions by specifying different exception types.\n# Handling multiple exceptions\ntry:\n    value = int(\"abc\")  # This will raise a ValueError\nexcept ValueError:\n    print(\"Invalid number format.\")  # Output: Invalid number format.\nexcept ZeroDivisionError:\n    print(\"Division by zero is not allowed.\")\n\n\n3.1.4.3 Using else and finally\n\nelse: Executes if no exception occurs.\nfinally: Executes no matter what, useful for cleanup actions.\n\n# Using else and finally with try-except\ntry:\n    num = 5\n    result = num / 1\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero.\")\nelse:\n    print(\"Division successful:\", result)  # Output: Division successful: 5.0\nfinally:\n    print(\"Execution complete.\")  # Output: Execution complete.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures in Python</span>"
    ]
  },
  {
    "objectID": "04.function.html",
    "href": "04.function.html",
    "title": "4  Functions and Packages in Python",
    "section": "",
    "text": "4.1 Functions in Python\nFunctions are reusable blocks of code that perform specific tasks. They help in organizing code, making it modular, readable, and easy to maintain. Python allows you to define your own functions, and it also comes with many built-in functions.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions and Packages in Python</span>"
    ]
  },
  {
    "objectID": "04.function.html#functions-in-python",
    "href": "04.function.html#functions-in-python",
    "title": "4  Functions and Packages in Python",
    "section": "",
    "text": "4.1.1 What is a Function?\nA function is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and allow code reuse.\n\n4.1.1.1 Key Points:\n\nModularity: Functions divide complex problems into smaller, manageable tasks.\nReusability: Functions allow the code to be used repeatedly without rewriting.\nReadability: Well-defined functions make the code clearer and easier to understand.\n\n\n\n\n4.1.2 Defining a Function\nFunctions are defined using the def keyword, followed by the function name and parentheses () containing any parameters. The function body is indented and contains the code that runs when the function is called.\n\n4.1.2.1 Basic Syntax\n# Defining a simple function\ndef function_name(parameters):\n    \"\"\"\n    Optional docstring describing the function.\n    \"\"\"\n    # Function body\n    # Code to execute\n    return value  # Optional return statement\n\n\n4.1.2.2 Example of a Simple Function\n# A function to add two numbers\ndef add(a, b):\n    return a + b\n\n# Calling the function\nresult = add(3, 5)\nprint(result)  # Output: 8\n\n\n\n4.1.3 Function Parameters and Arguments\n\n4.1.3.1 Positional Arguments\nArguments passed to a function in the order they are defined.\n# Function with positional arguments\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\ngreet(\"Alice\", \"Hello\")  # Output: Hello, Alice!\n\n\n4.1.3.2 Default Arguments\nDefault arguments allow parameters to have default values, which are used if no argument is provided.\n# Function with default arguments\ndef greet(name, message=\"Hello\"):\n    print(f\"{message}, {name}!\")\n\ngreet(\"Bob\")           # Output: Hello, Bob!\ngreet(\"Charlie\", \"Hi\") # Output: Hi, Charlie!\n\n\n4.1.3.3 Keyword Arguments\nKeyword arguments are passed by explicitly specifying the parameter names, allowing you to change the order of arguments.\n# Function with keyword arguments\ndef describe_pet(animal_type, pet_name):\n    print(f\"I have a {animal_type} named {pet_name}.\")\n\ndescribe_pet(pet_name=\"Max\", animal_type=\"dog\")  # Output: I have a dog named Max.\n\n\n4.1.3.4 Variable-Length Arguments (*args and **kwargs)\n\n*args allows a function to accept any number of positional arguments, which are passed as a tuple.\n**kwargs allows a function to accept any number of keyword arguments, which are passed as a dictionary.\n\n# Using *args\ndef sum_all(*args):\n    return sum(args)\n\nprint(sum_all(1, 2, 3, 4))  # Output: 10\n\n# Using **kwargs\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=30)  \n# Output:\n# name: Alice\n# age: 30\n\n\n\n4.1.4 Return Statement\nThe return statement is used to exit a function and return a value. If no return statement is used, the function will return None by default.\n# Function with a return statement\ndef square(x):\n    return x * x\n\nresult = square(5)\nprint(result)  # Output: 25\n\n\n4.1.5 Lambda Functions\nA lambda function is a small, anonymous function defined using the lambda keyword. Lambda functions can have any number of arguments but only one expression. They are often used for short, simple operations that are used once or as arguments to other functions.\n\n4.1.5.1 Basic Syntax of a Lambda Function\n# Syntax of a lambda function\n# lambda arguments: expression\n\n# Example of a lambda function to add two numbers\nadd = lambda x, y: x + y\nprint(add(3, 5))  # Output: 8\n\n\n4.1.5.2 Use Cases of Lambda Functions\n\nUsing with map(), filter(), and reduce(): Lambda functions are commonly used with these built-in functions for quick operations.\n\n# Using lambda with map() to square each number in a list\nnumbers = [1, 2, 3, 4]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared)  # Output: [1, 4, 9, 16]\n\nSorting by a Custom Key: You can use lambda functions as the key argument in sorting.\n\n# Sorting a list of tuples by the second element using a lambda function\npoints = [(2, 3), (1, 2), (3, 1)]\nsorted_points = sorted(points, key=lambda x: x[1])\nprint(sorted_points)  # Output: [(3, 1), (1, 2), (2, 3)]\n\n\n4.1.5.3 Limitations of Lambda Functions\n\nLimited to a single expression.\nLess readable for complex operations compared to regular functions.\nCannot contain statements or annotations.\n\n\n\n\n4.1.6 Scope and Lifetime of Variables\nVariables defined inside a function are local to that function and cannot be accessed outside. Variables defined outside functions are global.\n# Scope example\ndef my_function():\n    local_var = \"I am local\"\n    print(local_var)\n\nmy_function()            # Output: I am local\n# print(local_var)       # This would raise an error: NameError\n\n\n4.1.7 Docstrings\nDocstrings are used to document functions. They provide a way to describe what the function does, its parameters, and its return value.\n# Function with a docstring\ndef multiply(a, b):\n    \"\"\"\n    Multiply two numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The product of a and b.\n    \"\"\"\n    return a * b\n\nhelp(multiply)  # This will display the function's docstring",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions and Packages in Python</span>"
    ]
  },
  {
    "objectID": "04.function.html#packages",
    "href": "04.function.html#packages",
    "title": "4  Functions and Packages in Python",
    "section": "4.2 Packages",
    "text": "4.2 Packages\nA package is a collection of Python modules grouped together within a directory. Packages help organize and distribute reusable code across multiple projects. They make it easy to manage and share code.\n\n4.2.1 Importing a Package\nYou can import specific modules from a package or import the entire package.\n# Importing a specific module from a package\nfrom mypackage import module1\n\n# Importing a specific function from a module within a package\nfrom mypackage.module1 import my_function\n\n\n4.2.2 Using Standard Packages\nPython has a rich standard library with many built-in packages, such as math, os, and random. You can also install third-party packages using pip.\n# Using a function from the math package\nimport math\n\nresult = math.sqrt(16)\nprint(result)  # Output: 4.0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions and Packages in Python</span>"
    ]
  },
  {
    "objectID": "04.function.html#difference-between-functions-and-methods",
    "href": "04.function.html#difference-between-functions-and-methods",
    "title": "4  Functions and Packages in Python",
    "section": "4.3 Difference Between Functions and Methods",
    "text": "4.3 Difference Between Functions and Methods\n\n4.3.1 Functions\n\nDefinition: A function is a block of reusable code that performs a specific task. It can be defined using the def keyword and can be called independently of objects.\nUsage: Functions are generally used to perform a task, and they can accept parameters and return values.\n\n# Example of a function\ndef greet(name):\n    return f\"Hello, {name}!\"\n\nprint(greet(\"Alice\"))  # Output: Hello, Alice!\n\n\n4.3.2 Methods\n\nDefinition: A method is a function that is associated with an object. It is called on an object and usually works with the data contained in that object.\nUsage: Methods are used to perform operations on objects and are called using the dot notation.\n\n# Example of a method in a class\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def greet(self):\n        return f\"Hello, {self.name}!\"\n\n# Creating an object and calling the greet method\nperson = Person(\"Bob\")\nprint(person.greet())  # Output: Hello, Bob!\n\n\n4.3.3 Key Differences\n\nAssociation: Functions are standalone, while methods are associated with objects.\nCalling: Functions are called directly, while methods are called on objects using dot notation.\nFirst Parameter: Methods often have self as their first parameter, referring to the object itself, whereas functions do not.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions and Packages in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html",
    "href": "05.pandas.html",
    "title": "5  Data Analysis in Python",
    "section": "",
    "text": "5.1 Series\nA Series is a one-dimensional array-like object provided by pandas that can hold data of any type (integers, floats, strings, Python objects, etc.). It is similar to a column in an Excel spreadsheet or a single-column DataFrame in pandas. Each element in a Series has an associated index, which is used to access individual elements.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#series",
    "href": "05.pandas.html#series",
    "title": "5  Data Analysis in Python",
    "section": "",
    "text": "5.1.1 Creating a Series\nYou can create a Series in pandas using various data structures such as lists, dictionaries, or NumPy arrays. You can also specify the index manually.\n\n5.1.1.1 Creating a Series from a List\nThe simplest way to create a Series is by passing a list to the pd.Series() constructor.\nimport pandas as pd\n\n# Creating a Series from a list\ndata = [10, 20, 30, 40]\nseries = pd.Series(data)\nprint(series)\nOutput:\n0    10\n1    20\n2    30\n3    40\ndtype: int64\nIn this example, the default index starts at 0 and increments by 1.\n\n\n5.1.1.2 Creating a Series with Custom Index\nYou can specify custom indices when creating a Series, making it more descriptive.\n# Creating a Series with custom indices\ndata = [100, 200, 300]\nindex = ['a', 'b', 'c']\ncustom_series = pd.Series(data, index=index)\nprint(custom_series)\nOutput:\na    100\nb    200\nc    300\ndtype: int64\n\n\n5.1.1.3 Creating a Series from a Dictionary\nYou can also create a Series from a dictionary, where keys become the indices, and values become the Series values.\n# Creating a Series from a dictionary\ndata_dict = {'apple': 50, 'banana': 30, 'cherry': 20}\nfruit_series = pd.Series(data_dict)\nprint(fruit_series)\nOutput:\napple     50\nbanana    30\ncherry    20\ndtype: int64\n\n\n\n5.1.2 Selecting Elements\nSelecting elements from a Series can be done using indexing and slicing, similar to Python lists and NumPy arrays. The indexing can be done using integer-based indexing or label-based indexing if a custom index is set.\n\n5.1.2.1 1.2.1 Accessing Single Elements\nYou can access single elements by using their index position or label.\n# Accessing elements by index position\nprint(series[0])    # Output: 10\n\n# Accessing elements by index label\nprint(custom_series['b'])  # Output: 200\n\n\n5.1.2.2 Slicing a Series\nSlicing allows you to select a range of elements from a Series.\n# Slicing using index positions\nprint(series[1:3])  # Output: \n# 1    20\n# 2    30\n# dtype: int64\n\n# Slicing using index labels\nprint(custom_series['a':'b'])  # Output:\n# a    100\n# b    200\n# dtype: int64\n\n\n\n5.1.3 Series Operations\nSeries in pandas support vectorized operations, which means you can perform operations on entire Series without writing loops. These operations are element-wise, and pandas will align data using the index.\n\n5.1.3.1 Arithmetic Operations\nYou can perform arithmetic operations like addition, subtraction, multiplication, and division directly on Series.\n# Arithmetic operations\nseries1 = pd.Series([1, 2, 3, 4])\nseries2 = pd.Series([10, 20, 30, 40])\n\n# Adding two Series\nsum_series = series1 + series2\nprint(sum_series)\n\n# Output:\n# 0    11\n# 1    22\n# 2    33\n# 3    44\n# dtype: int64\n\n\n5.1.3.2 Mathematical Functions\nYou can use mathematical functions like mean(), sum(), max(), and others on Series.\n# Using mathematical functions\nvalues = pd.Series([5, 10, 15, 20])\nprint(\"Mean:\", values.mean())   # Output: Mean: 12.5\nprint(\"Sum:\", values.sum())     # Output: Sum: 50\nprint(\"Max:\", values.max())     # Output: Max: 20\n\n\n5.1.3.3 Applying Functions with apply()\nThe apply() function allows you to apply a custom function to each element in the Series.\n# Applying a custom function to each element\ndef square(x):\n    return x * x\n\nsquared_series = values.apply(square)\nprint(squared_series)\n\n# Output:\n# 0     25\n# 1    100\n# 2    225\n# 3    400\n# dtype: int64\n\n\n5.1.3.4 Handling Missing Data\nSeries can handle missing data (NaN values), and you can manipulate these values using methods like fillna(), dropna(), and isna().\n# Series with missing values\ndata_with_nan = pd.Series([1, 2, None, 4])\nprint(data_with_nan)\n\n# Filling missing values\nfilled_series = data_with_nan.fillna(0)\nprint(filled_series)\n\n# Output:\n# 0    1.0\n# 1    2.0\n# 2    0.0\n# 3    4.0\n# dtype: float64\n\n\n\n5.1.4 Conclusion\nSeries in pandas is a powerful tool for one-dimensional data manipulation, allowing for efficient data access, arithmetic operations, and handling of missing data. Understanding Series is fundamental to working with more complex pandas data structures like DataFrames.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#dataframe",
    "href": "05.pandas.html#dataframe",
    "title": "5  Data Analysis in Python",
    "section": "5.2 DataFrame",
    "text": "5.2 DataFrame\nA DataFrame is a two-dimensional, size-mutable, and heterogeneous tabular data structure with labeled axes (rows and columns) in pandas. Think of it as a table of data, similar to an Excel spreadsheet or a SQL table, which can hold data of various types (strings, integers, floats, etc.).\n\n5.2.1 Creating and Modifying DataFrames\nDataFrames can be created from various sources, including lists, dictionaries, NumPy arrays, and even other pandas objects like Series.\n\n5.2.1.1 Creating a DataFrame from a Dictionary\nThe most common way to create a DataFrame is by using a dictionary, where the keys become column names, and the values are lists representing column data.\nimport pandas as pd\n\n# Creating a DataFrame from a dictionary\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie'],\n    'Age': [25, 30, 35],\n    'City': ['New York', 'Los Angeles', 'Chicago']\n}\ndf = pd.DataFrame(data)\nprint(df)\nOutput:\n      Name  Age         City\n0    Alice   25     New York\n1      Bob   30  Los Angeles\n2  Charlie   35      Chicago\n\n\n5.2.1.2 Creating a DataFrame from a List of Lists\nYou can create a DataFrame from a list of lists, specifying column names separately.\n# Creating a DataFrame from a list of lists\ndata = [\n    ['Alice', 25, 'New York'],\n    ['Bob', 30, 'Los Angeles'],\n    ['Charlie', 35, 'Chicago']\n]\ncolumns = ['Name', 'Age', 'City']\ndf = pd.DataFrame(data, columns=columns)\nprint(df)\n\n\n5.2.1.3 Creating a DataFrame from a NumPy Array\nDataFrames can also be created from NumPy arrays. You must specify column names as pandas does not infer them automatically.\nimport numpy as np\n\n# Creating a DataFrame from a NumPy array\narray_data = np.array([[1, 2], [3, 4], [5, 6]])\ndf = pd.DataFrame(array_data, columns=['Column1', 'Column2'])\nprint(df)\n\n\n5.2.1.4 Modifying a DataFrame\nYou can add, modify, or delete rows and columns in a DataFrame.\nAdding a Column:\n# Adding a new column to an existing DataFrame\ndf['Score'] = [90, 85, 88]\nprint(df)\nModifying a Column:\n# Modifying an existing column\ndf['Age'] = df['Age'] + 1\nprint(df)\nDeleting a Column:\n# Deleting a column\ndf.drop('Score', axis=1, inplace=True)\nprint(df)\n\n\n\n5.2.2 Selecting Rows and Columns\nSelecting data from a DataFrame can be done using indexing, loc, and iloc.\n\n5.2.2.1 Selecting Columns\nColumns can be selected using square brackets, dot notation, or loc.\n# Selecting a single column\nnames = df['Name']\nprint(names)\n\n# Selecting multiple columns\nsubset = df[['Name', 'City']]\nprint(subset)\n\n\n5.2.2.2 Selecting Rows\nRows can be selected by index position using iloc or by label using loc.\nUsing iloc (Index Location):\niloc selects rows and columns by integer index positions.\n# Selecting rows using iloc\nprint(df.iloc[0])  # First row\nprint(df.iloc[1:3])  # Slicing rows\nUsing loc (Label Location):\nloc selects rows and columns by label (index and column names).\n# Selecting rows using loc\ndf.set_index('Name', inplace=True)  # Setting 'Name' column as index\nprint(df.loc['Alice'])  # Select row with index 'Alice'\n\n\n\n5.2.3 Filtering Data in DataFrames\nFiltering allows you to extract specific rows based on conditions.\nFiltering Rows Based on Conditions:\n# Filtering rows where Age &gt; 30\nfiltered_df = df[df['Age'] &gt; 30]\nprint(filtered_df)\n\n\n5.2.4 Adding and Removing Rows\nYou can add rows to a DataFrame using the append() method and remove rows using drop().\n\n5.2.4.1 Adding Rows\n# Adding a new row using append() # will be expired.\nnew_row = pd.DataFrame([['David', 28, 'Seattle']], columns=['Name', 'Age', 'City'])\ndf = df.append(new_row, ignore_index=True)\nprint(df)\nHere’s the revised version using updated pandas methods such as pd.concat() instead of append():\nimport pandas as pd\n\n# Creating the initial DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie'],\n    'Age': [25, 30, 35],\n    'City': ['New York', 'Los Angeles', 'Chicago']\n}\ndf = pd.DataFrame(data)\n\n# Adding a new row using pd.concat()\nnew_row = pd.DataFrame([['David', 28, 'Seattle']], columns=['Name', 'Age', 'City'])\ndf = pd.concat([df, new_row], ignore_index=True)\nprint(df)\n\n\n5.2.4.2 Removing Rows\n# Removing rows by index\ndf = df.drop(0)  # Removes the first row\nprint(df)\nIn this updated code: - Rows are added using pd.concat(), which is the recommended method in the newer versions of pandas. - The drop() method is still valid and is used to remove rows by their index.\n\n\n\n5.2.5 Handling Missing Data in DataFrames\nHandling missing data is essential for clean and accurate data analysis.\n\n5.2.5.1 Identifying Missing Data\nimport pandas as pd\nimport numpy as np\n\n# Creating a DataFrame with missing values\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'Age': [25, 30, np.nan, 40],\n    'Salary': [50000, 60000, np.nan, 80000]\n}\ndf = pd.DataFrame(data)\n\n# Checking for missing data\nprint(df.isna())  # Returns a DataFrame of booleans\nprint(df.isna().sum())  # Sum of missing values in each column\n\n\n5.2.5.2 Filling Missing Data\nYou can fill missing data with a specific value, such as 0 or the mean of the column.\n# Filling missing values with a specified value\ndf['Age'].fillna(df['Age'].mean(), inplace=True)\nThe warning you received is related to pandas’ behavior when using chained assignments. In future versions, using inplace=True with column-level operations might not work as expected. To fix this issue and ensure compatibility with future versions of pandas, you should avoid using inplace=True in this context. Instead, you can assign the result of the fillna() operation directly back to the DataFrame.\nHere’s the corrected code:\nimport pandas as pd\nimport numpy as np\n\n# Creating a DataFrame with missing values\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'Age': [25, 30, np.nan, 40],\n    'Salary': [50000, 60000, np.nan, 80000]\n}\ndf = pd.DataFrame(data)\n\n# Filling missing values in the 'Salary' column and assigning back to the original DataFrame\ndf['Salary'] = df['Salary'].fillna(df['Salary'].mean())\n\nprint(df)\n\n\n5.2.5.3 Dropping Missing Data\nRemove rows or columns that contain missing values.\n# Dropping rows with missing values\ndf.dropna(inplace=True)\ndf\n\n\n\n5.2.6 Sorting Data in DataFrames\nSorting can be performed based on one or multiple columns using the sort_values() method.\n# Sorting DataFrame by a column\nsorted_df = df.sort_values(by='Age', ascending=False)\nprint(sorted_df)\n\n\n5.2.7 Grouping Data (cf. MS Excel ‘PivotTable’)\nGrouping data is useful for performing aggregate operations on subsets of data.\n\n5.2.7.1 Option 1: Select Numeric Columns Before Grouping\n# Grouping by a column and calculating the mean\nimport pandas as pd\n\n# Creating a DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Emma'],\n    'Age': [25, 30, 35, 40, 28],\n    'Salary': [50000, 60000, 70000, 80000, 55000],\n    'Department': ['HR', 'IT', 'IT', 'HR', 'HR']\n}\ndf = pd.DataFrame(data)\nprint(df)\n\n# Grouping by the 'Department' column and calculating the mean of only numeric columns\ngrouped = df.groupby('Department')[['Age', 'Salary']].mean()\n\nprint(grouped)\n\n\n5.2.7.2 Option 2: Use numeric_only=True (if available)\nimport pandas as pd\n\n# Creating a DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Emma'],\n    'Age': [25, 30, 35, 40, 28],\n    'Salary': [50000, 60000, 70000, 80000, 55000],\n    'Department': ['HR', 'IT', 'IT', 'HR', 'HR']\n}\ndf = pd.DataFrame(data)\n\n# Grouping by the 'Department' column and calculating the mean, ignoring non-numeric columns\ngrouped = df.groupby('Department').mean(numeric_only=True)\n\nprint(grouped)\n\n\n\n5.2.8 Merging DataFrames\nMerging combines multiple DataFrames into one, similar to SQL JOIN operations.\n\n5.2.8.1 Using merge()\n# Merging two DataFrames on a common column\ndf1 = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Score': [85, 90]})\ndf2 = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Grade': ['A', 'B']})\n\nprint(df1)\nprint('---')\nprint(df2)\nprint('---')\n\nmerged_df = pd.merge(df1, df2, on='Name')\nprint(merged_df)\n\n\n5.2.8.2 Using concat()\n# Concatenating DataFrames \ndf3 = pd.concat([df1, df2], axis=1)\nprint(df3)\n\n\n\n5.2.9 Exporting DataFrames\nYou can export DataFrames to various file formats, including CSV, Excel, and JSON.\n# Install the correct library\n!pip install openpyxl\n\nimport pandas as pd\nimport openpyxl\n\n# Creating a DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Emma'],\n    'Age': [25, 30, 35, 40, 28],\n    'Salary': [50000, 60000, 70000, 80000, 55000],\n    'Department': ['HR', 'IT', 'IT', 'HR', 'HR']\n}\ndf = pd.DataFrame(data)\n# Saving DataFrame to a CSV file\ndf.to_csv('output.csv', index=False)\n\n# Saving DataFrame to an Excel file\ndf.to_excel('output.xlsx', index=False)\n\n\n5.2.10 Conclusion\nDataFrames in pandas are versatile and powerful for handling tabular data in Python. They provide robust functionality for data manipulation, cleaning, and analysis, making them an essential tool for data scientists and analysts.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#loading-and-saving-data",
    "href": "05.pandas.html#loading-and-saving-data",
    "title": "5  Data Analysis in Python",
    "section": "5.3 Loading and Saving Data",
    "text": "5.3 Loading and Saving Data\nPandas provides powerful methods to load data from various file formats and save it back after manipulation. Common formats include CSV, Excel, JSON, and SQL databases.\n\n5.3.1 Loading Data\nPandas offers various functions to read data from external sources into DataFrames, allowing for quick data analysis and manipulation.\n\n5.3.1.1 Reading CSV Files\nThe read_csv() function reads data from a CSV file into a DataFrame. This is one of the most common methods to import data.\nimport pandas as pd\n\n# Reading a CSV file into a DataFrame\ndf = pd.read_csv('data.csv')\nprint(df.head())  # Display the first 5 rows\n\n\n5.3.1.2 Reading Excel Files\nTo read Excel files, use the read_excel() function. You can specify the sheet name if the Excel file contains multiple sheets.\n# Reading data from an Excel file\ndf = pd.read_excel('data.xlsx', sheet_name='Sheet1')\nprint(df.head())\n\n\n5.3.1.3 Reading JSON Files\nJSON files can be read using the read_json() function. JSON is commonly used for data exchange between systems.\n# Reading data from a JSON file\ndf = pd.read_json('data.json')\nprint(df.head())\n\n\n\n5.3.2 Saving Data\nOnce you have manipulated your data, you can save it back to your preferred format using pandas functions.\n\n5.3.2.1 Saving to CSV\nThe to_csv() function saves the DataFrame to a CSV file. You can choose whether to include the index or not.\n# Saving DataFrame to a CSV file\ndf.to_csv('output.csv', index=False)\n\n\n5.3.2.2 Saving to Excel\nTo save data to an Excel file, use the to_excel() function. You can also specify the sheet name.\n# Saving DataFrame to an Excel file\ndf.to_excel('output.xlsx', index=False, sheet_name='Results')\n\n\n5.3.2.3 Saving to JSON\nYou can save data to JSON format using the to_json() function, which is useful for data interchange between applications.\n# Saving DataFrame to a JSON file\ndf.to_json('output.json')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#exploring-summary-information-and-statistical-values",
    "href": "05.pandas.html#exploring-summary-information-and-statistical-values",
    "title": "5  Data Analysis in Python",
    "section": "5.4 Exploring Summary Information and Statistical Values",
    "text": "5.4 Exploring Summary Information and Statistical Values\nExploring data is an essential step in understanding the structure, distribution, and characteristics of your dataset. Pandas provides several methods to inspect and summarize DataFrames.\n\n5.4.1 Viewing Basic Information\nThe info() method provides a concise summary of the DataFrame, including the index, column names, non-null counts, and data types.\nimport pandas as pd\n\n# Expanding the data with more people and overlapping cities\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Emma', 'Frank', 'Grace', 'Hannah', 'Ian', 'Jack'],\n    'Age': [25, 30, 35, 28, 22, 40, 33, 26, 29, 31],\n    'City': ['New York', 'Los Angeles', 'Chicago', 'New York', 'Los Angeles', 'San Francisco', 'Chicago', 'Boston', 'New York', 'Boston']\n}\n\n# Creating the DataFrame\ndf = pd.DataFrame(data)\ndf\n# Viewing basic information about the DataFrame\nprint(df.info())\n\n\n5.4.2 Viewing Statistical Summaries\nThe describe() method generates descriptive statistics that summarize the central tendency, dispersion, and shape of the data distribution, excluding NaN values.\n# Viewing statistical summary of numerical columns\nprint(df.describe())\nYou can also include non-numerical data by specifying include='all'.\n# Including all columns, including non-numeric\nprint(df.describe(include='all'))\n\n\n5.4.3 Counting Unique Values\nThe value_counts() function counts the unique values in a column, which is particularly useful for categorical data.\n# Counting unique values in a column\nprint(df['City'].value_counts())\n\n\n5.4.4 Displaying First and Last Rows\nYou can use head() and tail() to view the first and last few rows of the DataFrame.\n# Displaying the first 5 rows\nprint(df.head())\n\n# Displaying the last 5 rows\nprint(df.tail())",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#handling-missing-data-1",
    "href": "05.pandas.html#handling-missing-data-1",
    "title": "5  Data Analysis in Python",
    "section": "5.5 Handling Missing Data",
    "text": "5.5 Handling Missing Data\nHandling missing data is a crucial aspect of data cleaning, as missing values can lead to incorrect analysis results.\n\n5.5.1 Identifying Missing Data\nUse isna() or isnull() to detect missing values. These methods return a DataFrame of booleans indicating the presence of missing values.\n# Creating a DataFrame with missing values for demonstrating missing data handling\ndata_with_missing = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Emma', 'Frank', 'Grace', 'Hannah', 'Ian', 'Jack'],\n    'Age': [25, 30, None, 28, 22, 40, 33, None, 29, 31],  # Introducing missing values in 'Age'\n    'City': ['New York', 'Los Angeles', 'Chicago', None, 'Los Angeles', 'San Francisco', 'Chicago', 'Boston', 'New York', None]  # Introducing missing values in 'City'\n}\n\n# Creating the DataFrame with missing data\ndf_missing = pd.DataFrame(data_with_missing)\ndf_missing\n# Identifying missing data\nprint(df_missing.isna())\n\n# Counting missing values in each column\nprint(df_missing.isna().sum())\n\n\n5.5.2 Removing Missing Data\nYou can remove rows or columns with missing values using the dropna() method.\n# Dropping rows with any missing values\ndf_cleaned1 = df_missing.dropna()\nprint(df_cleaned1)\n\n# Dropping columns with missing values\ndf_cleaned2 = df_missing.dropna(axis=1)\nprint(df_cleaned2)\n\n\n5.5.3 Filling Missing Data\nInstead of dropping missing data, you can fill it with specified values using fillna(). Common strategies include filling with zeros, the mean, or forward/backward filling.\n# Filling missing values with a specified value\ndf_missing['Age'].fillna(0)\n\n# Filling missing values with the column mean\ndf_missing['Age'].fillna(df_missing['Age'].mean())\ndf_missing\n\n# Forward filling missing values\ndf_missing.fillna(method='ffill')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#working-with-indices",
    "href": "05.pandas.html#working-with-indices",
    "title": "5  Data Analysis in Python",
    "section": "5.6 Working with Indices",
    "text": "5.6 Working with Indices\nThe index of a DataFrame is used to uniquely identify rows. Managing indices effectively allows for more efficient data manipulation and retrieval.\n\n5.6.1 Setting and Resetting Index\nYou can set a column as the index using set_index() and reset it back to the default integer index using reset_index().\n# Setting 'Name' as the index\ndf.set_index('Name', inplace=True)\nprint(df)\n\n# Resetting the index to default\ndf.reset_index(inplace=True)\nprint(df)\n\n\n5.6.2 Sorting by Index\nThe sort_index() method sorts the DataFrame by its index.\n# Sorting the DataFrame by index\ndf.sort_index(inplace=True)\nprint(df)\n\n\n5.6.3 Changing the Index Name\nYou can rename the index by assigning a new name directly.\n# Renaming the index\ndf.index.name = 'ID'\nprint(df)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#filtering-data",
    "href": "05.pandas.html#filtering-data",
    "title": "5  Data Analysis in Python",
    "section": "5.7 Filtering Data",
    "text": "5.7 Filtering Data\nFiltering allows you to select rows based on specific conditions, enabling targeted analysis and manipulation.\n\n5.7.1 Boolean Indexing\nBoolean indexing uses conditional statements to filter data.\n# Filtering rows where Age &gt; 30\nfiltered_df = df[df['Age'] &gt; 30]\nprint(filtered_df)\n\n\n5.7.2 Using isin() Method\nThe isin() method filters rows based on multiple values in a column.\n# Filtering rows where Name is Alice or Bob\nfiltered_df = df[df['Name'].isin(['Alice', 'Bob'])]\nprint(filtered_df)\n\n\n5.7.3 Filtering with Multiple Conditions\nYou can combine multiple conditions using & (and) or | (or).\n# Filtering with multiple conditions\nfiltered_df = df[(df['Age'] &gt; 30) & (df['City'] == 'Chicago')]\nprint(filtered_df)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#merging-dataframes-1",
    "href": "05.pandas.html#merging-dataframes-1",
    "title": "5  Data Analysis in Python",
    "section": "5.8 Merging DataFrames",
    "text": "5.8 Merging DataFrames\nMerging DataFrames is an essential operation when working with multiple datasets that need to be combined. Pandas offers several functions for merging, joining, and concatenating DataFrames.\n\n5.8.1 Using concat() Function\nThe concat() function concatenates DataFrames along rows (default) or columns. It is useful when you have DataFrames with the same columns and want to stack them.\nimport pandas as pd\n\n# Creating sample DataFrames\ndf1 = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30]})\ndf2 = pd.DataFrame({'Name': ['Charlie', 'David'], 'Age': [35, 40]})\n\n# Concatenating DataFrames vertically\ndf_concat = pd.concat([df1, df2], ignore_index=True)\nprint(df_concat)\n\n# Output:\n#       Name  Age\n# 0    Alice   25\n# 1      Bob   30\n# 2  Charlie   35\n# 3    David   40\nYou can also concatenate DataFrames horizontally by specifying axis=1.\n# Concatenating DataFrames horizontally\ndf_concat_horizontal = pd.concat([df1, df2], axis=1)\nprint(df_concat_horizontal)\n\n\n5.8.2 Using merge() Function\nThe merge() function combines two DataFrames based on a key column or index. It works similarly to SQL JOIN operations (inner, outer, left, right).\n# Creating sample DataFrames for merging\ndf1 = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Score': [85, 90]})\ndf2 = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Grade': ['A', 'B']})\n\n# Merging DataFrames on the 'Name' column\ndf_merged = pd.merge(df1, df2, on='Name', how='inner')\nprint(df_merged)\n\n# Output:\n#     Name  Score Grade\n# 0  Alice     85     A\n# 1    Bob     90     B\n\n5.8.2.1 SQL Join Methods\n\n5.8.2.1.1 1. Inner Join\nAn inner join returns rows when there is a match in both tables.\n\n\n5.8.2.1.2 2. Left Join (or Left Outer Join)\nA left join returns all rows from the left table, and the matched rows from the right table. If no match is found, the result is NULL on the right side.\n\n\n5.8.2.1.3 3. Right Join (or Right Outer Join)\nA right join returns all rows from the right table, and the matched rows from the left table. If no match is found, the result is NULL on the left side.\n\n\n5.8.2.1.4 4. Full Join (or Full Outer Join)\nA full join returns rows when there is a match in either table. It returns all rows from both tables and fills NULL where there is no match.\n\n\n\n\n5.8.2.2 Diagram of SQL Joins:\n1. INNER JOIN:\n+--------+     +--------+\n|  LEFT  |     |  RIGHT |\n+--------+     +--------+\n   +--------+     +--------+\n   | common |     | common |\n   +--------+     +--------+\n   \n2. LEFT JOIN:\n+--------+     +--------+\n|  LEFT  |     |  RIGHT |\n+--------+     +--------+\n   +--------+     +--------+\n   | all    |     | common |\n   | from   |     +--------+\n   | left   |\n   +--------+\n\n3. RIGHT JOIN:\n+--------+     +--------+\n|  LEFT  |     |  RIGHT |\n+--------+     +--------+\n   +--------+     +--------+\n   | common |     | all    |\n   +--------+     | from   |\n                  | right  |\n                  +--------+\n\n4. FULL JOIN:\n+--------+     +--------+\n|  LEFT  |     |  RIGHT |\n+--------+     +--------+\n   +--------+     +--------+\n   | all    |     | all    |\n   | from   |     | from   |\n   | both   |     | both   |\n   +--------+     +--------+\n\n\n\n5.8.2.3 Python Example with DataFrames\nLet’s create two DataFrames and perform different types of joins using the merge() function in pandas, which simulates SQL joins.\nimport pandas as pd\n\n# Creating two DataFrames\ndf1 = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'Age': [25, 30, 35, 40]\n})\n\ndf2 = pd.DataFrame({\n    'Name': ['Alice', 'Charlie', 'Eve'],\n    'City': ['New York', 'Chicago', 'Los Angeles']\n})\n\n# Display the DataFrames\nprint(\"DataFrame 1:\")\nprint(df1)\nprint(\"DataFrame 2:\")\nprint(df2)\n\n# Inner Join\ninner_join = pd.merge(df1, df2, on='Name', how='inner')\nprint(\"\\nInner Join:\")\nprint(inner_join)\n\n# Left Join\nleft_join = pd.merge(df1, df2, on='Name', how='left')\nprint(\"\\nLeft Join:\")\nprint(left_join)\n\n# Right Join\nright_join = pd.merge(df1, df2, on='Name', how='right')\nprint(\"\\nRight Join:\")\nprint(right_join)\n\n# Full Outer Join\nfull_join = pd.merge(df1, df2, on='Name', how='outer')\nprint(\"\\nFull Outer Join:\")\nprint(full_join)\n\n\n\n5.8.3 Using join() Function\nThe join() function is used to join two DataFrames based on their indices. It is particularly useful for merging DataFrames with overlapping indices.\n# Creating sample DataFrames with indices\ndf1 = pd.DataFrame({'Score': [85, 90]}, index=['Alice', 'Bob'])\ndf2 = pd.DataFrame({'Grade': ['A', 'B']}, index=['Alice', 'Bob'])\n\n# Joining DataFrames on indices\ndf_joined = df1.join(df2)\nprint(df_joined)\n\n# Output:\n#        Score Grade\n# Alice     85     A\n# Bob       90     B",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#reshaping-data",
    "href": "05.pandas.html#reshaping-data",
    "title": "5  Data Analysis in Python",
    "section": "5.9 Reshaping Data",
    "text": "5.9 Reshaping Data\nReshaping allows you to change the layout of a DataFrame, making it suitable for different types of analysis.\n\n5.9.1 Using melt() Function\nThe melt() function unpivots a DataFrame from a wide format to a long format, making it easier to analyze and visualize.\n# Creating a sample DataFrame\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob'],\n    'Math': [90, 80],\n    'Science': [85, 95]\n})\n\n# Melting the DataFrame\ndf_melted = pd.melt(df, id_vars=['Name'], value_vars=['Math', 'Science'], \n                    var_name='Subject', value_name='Score')\nprint(df_melted)\n\n# Output:\n#     Name  Subject  Score\n# 0  Alice     Math     90\n# 1    Bob     Math     80\n# 2  Alice  Science     85\n# 3    Bob  Science     95\n\n\n5.9.2 Using pivot_table() Function\nThe pivot_table() function reshapes data by creating a new summary table, which is useful for aggregating data.\n# Creating a DataFrame for pivoting\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Alice', 'Bob'],\n    'Subject': ['Math', 'Math', 'Science', 'Science'],\n    'Score': [90, 80, 85, 95]\n})\n\nprint(df)\nprint('---')\n\n# Pivoting the DataFrame\ndf_pivot = df.pivot_table(values='Score', index='Name', columns='Subject', \n                          aggfunc='mean')\nprint(df_pivot)\n\n# Output:\n# Subject  Math  Science\n# Name                  \n# Alice      90       85\n# Bob        80       95\n\n\n5.9.3 Using stack() and unstack()\nstack() compresses columns into rows, while unstack() does the opposite, expanding rows into columns.\n# Stacking and unstacking a DataFrame\ndf = pd.DataFrame({\n    'A': [1, 2],\n    'B': [3, 4]\n}, index=['X', 'Y'])\n\n# Stacking the DataFrame\nstacked = df.stack()\nprint(stacked)\n\n# Unstacking the stacked DataFrame\nunstacked = stacked.unstack()\nprint(unstacked)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#applying-functions-to-dataframes",
    "href": "05.pandas.html#applying-functions-to-dataframes",
    "title": "5  Data Analysis in Python",
    "section": "5.10 Applying Functions to DataFrames",
    "text": "5.10 Applying Functions to DataFrames\nApplying functions to DataFrames allows you to transform data easily, using built-in or custom functions.\n\n5.10.1 Applying Functions to Series\nThe apply() function applies a function along an axis of the DataFrame.\n# Creating a sample DataFrame\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6]\n})\n\n# Applying a function to each column\ndf_squared = df.apply(lambda x: x ** 2)\nprint(df_squared)\n\n# Output:\n#    A   B\n# 0  1  16\n# 1  4  25\n# 2  9  36\n\n# Applying a function to each column\n# def square(x):\n#     y = x ** 2\n#     return y\n\n# df_squared = df.apply(square)\n\n\n5.10.2 Applying Functions to Entire DataFrames\nThe applymap() function applies a function to each element of the DataFrame.\n# Applying a function to each element\ndf_negated = df.applymap(lambda x: -x)\nprint(df_negated)\n\n# Output:\n#    A  B\n# 0 -1 -4\n# 1 -2 -5\n# 2 -3 -6",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#group-operations",
    "href": "05.pandas.html#group-operations",
    "title": "5  Data Analysis in Python",
    "section": "5.11 Group Operations",
    "text": "5.11 Group Operations\nGrouping data allows you to perform operations like aggregation, transformation, and filtering on subsets of your data.\n\n5.11.1 Splitting Data into Groups\nThe groupby() function groups data based on one or more columns.\n# Creating a sample DataFrame\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Alice', 'Bob'],\n    'Subject': ['Math', 'Math', 'Science', 'Science'],\n    'Score': [90, 80, 85, 95]\n})\n\n# Grouping by 'Name'\ngrouped = df.groupby('Name')\nprint(grouped.mean())\n\n# Output:\n#        Score\n# Name        \n# Alice   87.5\n# Bob     87.5\n\n\n5.11.2 Performing Aggregations on Groups\nCommon aggregations include mean(), sum(), count(), and max().\n# Aggregating grouped data\nagg_df = grouped.agg({'Score': ['mean', 'sum']})\nprint(agg_df)\n\n# Output:\n#        Score      \n#         mean  sum\n# Name              \n# Alice   87.5  175\n# Bob     87.5  175",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "05.pandas.html#working-with-time-series-data",
    "href": "05.pandas.html#working-with-time-series-data",
    "title": "5  Data Analysis in Python",
    "section": "5.12 Working with Time Series Data",
    "text": "5.12 Working with Time Series Data\nPandas provides extensive functionality for time series data, allowing for date manipulation, resampling, and time-based indexing.\n\n5.12.1 Creating Time Series Data\nTime series data can be created using pd.date_range() to generate a range of dates.\n# Creating a time series DataFrame\ndate_rng = pd.date_range(start='2023-01-01', end='2023-01-10', freq='D')\ndf = pd.DataFrame(date_rng, columns=['Date'])\ndf['Data'] = range(10)\nprint(df)\n\n# Output:\n#         Date  Data\n# 0 2023-01-01     0\n# 1 2023-01-02     1\n# 2 2023-01-03     2\n# ...            ...\n# 9 2023-01-10     9\n\n\n5.12.2 Resampling Time Series Data\nThe resample() function allows for changing the frequency of time series data, such as converting daily data to monthly.\n# Creating a time series DataFrame with hourly data\ndate_rng = pd.date_range(start='2023-01-01', end='2023-01-02', freq='H')\ndf = pd.DataFrame(date_rng, columns=['Date'])\ndf['Data'] = range(len(df))\n\n# Resampling to daily data\ndf.set_index('Date', inplace=True)\nresampled_df = df.resample('D').sum()\nprint(resampled_df)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AI Programming Class",
    "section": "",
    "text": "Preface\nThis material has been compiled for use in the AI Programming class of IGSE for Fall 2024. The materials are primarily targeted at linguistics students.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "05.pandas.html#section",
    "href": "05.pandas.html#section",
    "title": "5  Data Analysis in Python",
    "section": "5.11 ",
    "text": "5.11",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Analysis in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html",
    "href": "07.Regular_Expression.html",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "",
    "text": "7.1 1. Basics of Regular Expressions\nHere are some basic symbols in regular expressions:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#basics-of-regular-expressions",
    "href": "07.Regular_Expression.html#basics-of-regular-expressions",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "",
    "text": ". : Matches any single character except newline.\n^ : Asserts the start of a string.\n$ : Asserts the end of a string.\n[]: Defines a set of characters. For example, [abc] matches either “a”, “b”, or “c”.\n\\d: Matches any digit (equivalent to [0-9]).\n\\w: Matches any word character (alphanumeric and underscore, equivalent to [a-zA-Z0-9_]).\n\\s: Matches any whitespace character (spaces, tabs, etc.).\n*: Matches 0 or more occurrences of the preceding element.\n+: Matches 1 or more occurrences.\n?: Matches 0 or 1 occurrence.\n{n,m}: Matches between n and m occurrences of the preceding element.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#findall-finding-all-matches",
    "href": "07.Regular_Expression.html#findall-finding-all-matches",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.2 2. findall(): Finding All Matches",
    "text": "7.2 2. findall(): Finding All Matches\nThe findall() function in Python returns a list of all matches for a given pattern.\nimport re\n\ndata = \"1234 abc가나다ABC_555_6 13 43435 2213433577869 23ab\"\n\n# Finding single digits\nprint(re.findall(\"[0-9]\", data))  # ['1', '2', '3', '4', '5', '5', '5', ...]\n\n# Finding sequences of digits\nprint(re.findall(\"[0-9]+\", data))  # ['1234', '555', '6', '13', '43435', ...]\n\n# Finding exactly two-digit numbers\nprint(re.findall(\"[0-9]{2}\", data))  # ['12', '34', '55', '13', '43', ...]\n\n# Finding numbers with 2 to 6 digits\nprint(re.findall(\"[0-9]{2,6}\", data))  # ['1234', '555', '13', '43435', ...]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#matching-specific-patterns",
    "href": "07.Regular_Expression.html#matching-specific-patterns",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.3 3. Matching Specific Patterns",
    "text": "7.3 3. Matching Specific Patterns\ndata = \"1234 abc가나다ABC_555_6 mbc kbs sbs 58672 newsline kkbc dreamair air airline air\"\n\n# Finding patterns that start with 'a' followed by two characters\nprint(re.findall(\"a..\", data))  # ['abc', 'air', 'air']\n\n# Finding strings that end with \"air\"\nprint(re.findall(\"air$\", data))  # ['air']",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#finding-numeric-patterns",
    "href": "07.Regular_Expression.html#finding-numeric-patterns",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.4 4. Finding Numeric Patterns",
    "text": "7.4 4. Finding Numeric Patterns\n\\d is used to represent any digit, and it is one of the most commonly used patterns.\ndata = \"johnson 80, Bong 100, David 50\"\nprint(re.findall(\"\\d\", data))  # ['8', '0', '1', '0', '0', '5', '0']\nprint(re.findall(\"\\d{2}\", data))  # ['80', '10', '00', '50']",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#split-splitting-strings",
    "href": "07.Regular_Expression.html#split-splitting-strings",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.5 5. split(): Splitting Strings",
    "text": "7.5 5. split(): Splitting Strings\nRegular expressions can be used to split strings based on various patterns.\n# Splitting based on space (default)\nprint(\"mbc,kbs sbs:ytn\".split())  # ['mbc,kbs', 'sbs:ytn']\n\n# Splitting based on commas\nprint(\"mbc,kbs sbs:ytn\".split(\",\"))  # ['mbc', 'kbs sbs:ytn']\n\n# Splitting using a regex pattern (\\W means non-alphanumeric characters)\nprint(re.split(\"\\W+\", \"mbc,kbs sbs:ytn\"))  # ['mbc', 'kbs', 'sbs', 'ytn']",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#sub-substituting-strings",
    "href": "07.Regular_Expression.html#sub-substituting-strings",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.6 6. sub(): Substituting Strings",
    "text": "7.6 6. sub(): Substituting Strings\nThe sub() function is used to replace parts of a string that match a pattern with another string.\nnumber = \"1234 abc가나다ABC_567_34234\"\nprint(number)  # Original string\n\n# Replacing any digits with '888'\nm = re.sub(\"[0-9]+\", \"888\", number)\nprint(m)  # '888 abc가나다ABC_888_888'",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#key-components-of-regular-expressions",
    "href": "07.Regular_Expression.html#key-components-of-regular-expressions",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "",
    "text": "Literals: Exact characters to match. For example, \"cat\" will match the string \"cat\" in text.\nMeta-characters: Special symbols that represent types of characters or positions in the text.\n\n. : Matches any single character except newline.\n^ : Asserts the start of a string.\n$ : Asserts the end of a string.\n[]: Defines a set of characters. For example, [abc] matches either “a”, “b”, or “c”.\n\\d: Matches any digit (equivalent to [0-9]).\n\\w: Matches any word character (alphanumeric and underscore, equivalent to [a-zA-Z0-9_]).\n\\s: Matches any whitespace character (spaces, tabs, etc.).\n\n\n\n7.1.1 Quantifiers:\n-   `*`: Matches 0 or more occurrences of the preceding element.\n-   `+`: Matches 1 or more occurrences.\n-   `?`: Matches 0 or 1 occurrence.\n-   `{n,m}`: Matches between n and m occurrences of the preceding element.\n\n\n7.1.2 Example:\nFor the string \"The quick brown fox jumps over 12 lazy dogs.\":\n\nThe pattern \\d+ would match the sequence of digits \"12\".\nThe pattern \\w+ would match words like \"The\", \"quick\", \"brown\", etc.\n\nRegular expressions are widely used in text processing tasks, such as search engines, text editors, and programming languages like Python, JavaScript, and many others.\n## 1. Basics of Regular Expressions\nHere are some basic symbols in regular expressions:\n\n. : Any single character\n^ : The start of a string\n$ : The end of a string\n[] : Character set\n\\d : Digit (0-9)\n\\w : Alphanumeric characters (0-9, a-z, A-Z)\n\\s : Whitespace character\n+ : One or more occurrences\n* : Zero or more occurrences\n{n,m} : Between n and m occurrences",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#examples",
    "href": "07.Regular_Expression.html#examples",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.7 Examples",
    "text": "7.7 Examples\nThank you for sharing the image of your Excel data. To help you use this as an example in your regular expression textbook, we can focus on several key aspects of preprocessing this text. Here are some steps we could cover:\n\n7.7.1 Removing Special Characters\nThe text contains placeholders like “@@@” and non-standard line breaks, which can be removed or standardized. For instance: - Regex Pattern: @@@|\\n - This pattern will match both the placeholder and newlines.\nimport re\n\ntext = \"Hello. I'm @@@.\\nToday I brought that bear doll.\\nThis is a bear doll that I like...\"\nclean_text = re.sub(r\"@@@|\\n\", \"\", text)\nprint(clean_text)\n\n\n7.7.2 Lowercasing Text\nUniformity in text processing often requires converting all text to lowercase. - Regex or Method: .lower()\nlower_text = clean_text.lower()\n\n\n7.7.3 Correcting Simple Typos\nThe text contains phrases like “thank you.” where punctuation might need correction. We can use regex to identify incorrect casing or punctuation. - Regex Pattern: [Tt]hank you[.,]\nfixed_text = re.sub(r\"[Tt]hank you[.,]?\", \"Thank you.\", lower_text)\n\n\n7.7.4 Identifying Sentences or Key Phrases\nIf you want to extract specific phrases or sentences for further analysis: - Regex Pattern: r\"\\b(?:brought|present|special)\\b\"\nmatches = re.findall(r\"\\b(?:brought|present|special)\\b\", fixed_text)\nprint(matches)  # Extracts words like 'brought', 'present', 'special'\n\n\n7.7.5 Sentence Tokenization\nYou can split sentences based on punctuation using regex: - Regex Pattern: r\"[.!?]\\s+\"\nsentences = re.split(r\"[.!?]\\s+\", fixed_text)\nWould you like help with any specific part of the preprocessing, or should I walk you through more steps for preparing the text for analysis in your regular expression textbook?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#text-preprocessing-examples",
    "href": "07.Regular_Expression.html#text-preprocessing-examples",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.7 Text Preprocessing Examples",
    "text": "7.7 Text Preprocessing Examples\nThank you for sharing the image of your Excel data. To help you use this as an example in your regular expression textbook, we can focus on several key aspects of preprocessing this text. Here are some steps we could cover:\n\n7.7.1 Removing Special Characters\nThe text contains placeholders like “@@@” and non-standard line breaks, which can be removed or standardized. For instance:\n\nRegex Pattern: @@@|\\n\n\nThis pattern will match both the placeholder and newlines.\n\n\nimport re\n\ntext = \"Hello. I'm @@@.\\nToday I brought that bear doll.\\nThis is a bear doll that I like...\\n thank you. Thank you all.\"\nclean_text = re.sub(r\"@@@|\\n\", \"\", text)\nprint(clean_text)\n\n\n7.7.2 Lowercasing Text\nUniformity in text processing often requires converting all text to lowercase.\n\nRegex or Method: .lower()\n\nlower_text = clean_text.lower()\n\n\n7.7.3 Correcting Simple Typos\nThe text contains phrases like “thank you.” where punctuation might need correction. We can use regex to identify incorrect casing or punctuation.\n\nRegex Pattern: [Tt]hank you[.,]\n\nfixed_text = re.sub(r\"[Tt]hank you[.,]?\", \"Thank you.\", lower_text)\n\n\n7.7.4 Identifying Sentences or Key Phrases\nIf you want to extract specific phrases or sentences for further analysis:\n\nRegex Pattern: r\"\\b(?:brought|present|special)\\b\"\n\nmatches = re.findall(r\"\\b(?:brought|present|special)\\b\", fixed_text)\nprint(matches)  # Extracts words like 'brought', 'present', 'special'\n\n\n7.7.5 Sentence Tokenization\nYou can split sentences based on punctuation using regex:\n\nRegex Pattern: r\"[.!?]\\s+\"\n\nsentences = re.split(r\"[.!?]\\s+\", fixed_text)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "07.Regular_Expression.html#apply-regular-expression-in-dataframe",
    "href": "07.Regular_Expression.html#apply-regular-expression-in-dataframe",
    "title": "7  Regular Expressions (RegEx) in Python",
    "section": "7.8 Apply Regular Expression in DataFrame",
    "text": "7.8 Apply Regular Expression in DataFrame\n\n7.8.1 Step 1: Create a DataFrame\nFirst, we create a DataFrame from the sample data that was visible in the image.\nimport pandas as pd\n\n# Sample data based on the image\ndata = {\n    'NO': [1, 2, 3],\n    'Text_Typo': [\n        \"Hello. I'm @@@.\\nToday I brought that bear doll.\\nThis is a bear doll that I like.\\nThis bear doll is special to me because my aunt gave it to me.\\nI remember that it was my birthday present from my aunt.\\nI love my aunt.\\nThank you for listening to my presentation.\",\n        \"Hello, I'm @@@. Today I brought a baseball bat. This is a bat that makes me funny. This is special to me because I wanted to be a baseball player when I was a child. And I was a baseball player in baseball club. I remember that I played baseball with my friend. I was very happy at that time. Thank you.\",\n        \"Hello, I'm @@@. Let me show you this music box. It's special to me because it's my first music box. I was interested in the music.\"\n    ]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\nprint(df)\n\n\n7.8.2 Step 2: Apply Regular Expressions\nLet’s apply some regular expressions to clean up the text.\n\nRemove the placeholder “@@@” and extra line breaks \\n.\nLowercase the text for uniformity.\nReplace certain common typos like missing or incorrect punctuation around “thank you”.\nExtract key sentences using regular expressions.\n\n\n7.8.2.1 Applying Regular Expression to Each Row\nimport re\n\n# Function to clean text\ndef clean_text(text):\n    # Remove the placeholder and line breaks\n    text = re.sub(r\"@@@|\\n\", \"\", text)\n    \n    # Fix common typo with \"thank you\"\n    text = re.sub(r\"[Tt]hank you[.,]?\", \"Thank you.\", text)\n    \n    # Convert to lowercase\n    text = text.lower()\n    \n    return text\n\n# Apply the function to each row in the 'Text_Typo' column\ndf['Cleaned_Text'] = df['Text_Typo'].apply(clean_text)\n\n# Display the updated DataFrame\ndf[['NO', 'Text_Typo','Cleaned_Text']]\n\n\n\n7.8.3 Step 3: Extracting Specific Patterns\nIf you want to extract certain patterns like sentences containing the word “special” or phrases where the speaker brought an item, you can do this with regex as well.\n\n7.8.3.1 Extract Sentences with the Word “Special”\n# Function to extract sentences with the word \"special\"\ndef extract_special_sentences(text):\n    # Split sentences based on punctuation\n    sentences = re.split(r\"[.!?]\\s+\", text)\n    \n    # Find sentences containing the word \"special\"\n    special_sentences = [sent for sent in sentences if re.search(r\"\\bspecial\\b\", sent)]\n\n    ## FULL CODE ##\n    # special_sentences = []\n    # for sent in sentences:\n    #     if re.search(r\"\\bspecial\\b\", sent):\n    #         special_sentences.append(sent)    \n    \n    return special_sentences\n\n# Apply the function to extract sentences with \"special\"\ndf['Special_Sentences'] = df['Cleaned_Text'].apply(extract_special_sentences)\n\n# Display the DataFrame with extracted sentences\ndf[['NO', 'Text_Typo','Cleaned_Text', 'Special_Sentences']]\nThis DataFrame now contains cleaned text and a column with sentences that mention the word “special.”",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Regular Expressions (RegEx) in Python</span>"
    ]
  },
  {
    "objectID": "01.setup.html#both-environments-are-powerful-tools-for-data-analysis-and-the-choice-depends-on-your-specific-needs-and-workflow-preferences.",
    "href": "01.setup.html#both-environments-are-powerful-tools-for-data-analysis-and-the-choice-depends-on-your-specific-needs-and-workflow-preferences.",
    "title": "1  Setting Up Environment",
    "section": "1.4 Both environments are powerful tools for data analysis, and the choice depends on your specific needs and workflow preferences.",
    "text": "1.4 Both environments are powerful tools for data analysis, and the choice depends on your specific needs and workflow preferences.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting Up Environment</span>"
    ]
  }
]